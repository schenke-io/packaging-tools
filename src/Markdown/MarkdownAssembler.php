<?php

namespace SchenkeIo\PackagingTools\Markdown;

use Illuminate\Contracts\Filesystem\FileNotFoundException;
use SchenkeIo\PackagingTools\Contracts\MarkdownPieceInterface;
use SchenkeIo\PackagingTools\Setup\Config;
use SchenkeIo\PackagingTools\Setup\ProjectContext;

/**
 * Core engine for assembling Markdown documentation.
 *
 * This class provides a fluent API to collect various content blocks,
 * including raw Markdown files, dynamically generated badges, class
 * documentation, and tables of contents. It manages the assembly process,
 * ensuring proper block spacing and automatic generation of the final
 * documentation file (e.g., README.md) with an AI-friendly warning header.
 *
 * Core Features:
 * - Fluent Interface: Chain methods like addMarkdown(), badges(), and classes() for easy assembly.
 * - Content Providers: Extensible system to plugin dynamic content generators (Pieces).
 * - Table of Contents: Automatically generates a linked TOC based on headers in all blocks.
 * - Project Awareness: Uses ProjectContext to resolve file paths across different environments.
 * - AI Safety: Prepends a clear warning to the output file to discourage manual edits.
 *
 * Key Methods:
 * - init(): Static helper to bootstrap Markdown source directories and files.
 * - addMarkdown() / addText(): Methods to include static content.
 * - writeMarkdown(): Processes all blocks and writes the combined output to the filesystem.
 *
 * @markdown
 */
class MarkdownAssembler
{
    public const TOC_FLAG = '<!-- placeholder for the Table of contents -->';

    protected readonly string $sourceText;

    /**
     * @var array<int,string|MarkdownPieceInterface>
     */
    protected array $blocks = [];

    protected bool $autoHeaderUsed = false;

    public static function init(string $markdownDir, ?ProjectContext $projectContext = null): void
    {
        $projectContext = $projectContext ?? new ProjectContext;
        $fullPath = $projectContext->fullPath($markdownDir);

        if (! $projectContext->filesystem->isDirectory($fullPath)) {
            $projectContext->filesystem->makeDirectory($fullPath, 0755, true);
            Config::output("Created directory: $markdownDir");
        }

        $files = [
            'header.md',
            'installation.md',
            'usage.md',
            'features.md',
            'contributing.md',
        ];

        foreach ($files as $file) {
            $filePath = "$fullPath/$file";
            if (! $projectContext->filesystem->exists($filePath)) {
                $content = '# '.ucfirst(str_replace('.md', '', (string) $file))."\n\nContent goes here.\n";
                $projectContext->filesystem->put($filePath, $content);
                Config::output("Created file: $markdownDir/$file");
            }
        }
    }

    public function __construct(
        protected readonly string $markdownSourceDir,
        protected readonly ProjectContext $projectContext = new ProjectContext
    ) {
        $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2);
        $caller = $trace[0];
        $file = $caller['file'] ?? 'unknown file';
        $relativeFile = str_replace($this->projectContext->projectRoot.'/', '', $file);

        $this->sourceText = sprintf(<<<'EOM'
<!--
********************************************************************************
*                                                                              *
*     DO NOT EDIT THIS FILE MANUALLY! IT WILL BE OVERWRITTEN.                  *
*                                                                              *
*     This file was generated by: %s
*     Source files are located in: %s
*
*     If you want to change the content, edit the source files instead.        *
*                                                                              *
********************************************************************************
-->

EOM
            , $relativeFile, $markdownSourceDir
        );

    }

    public function autoHeader(): self
    {
        $this->autoHeaderUsed = true;
        $this->badges()->all();

        $title = ucwords(str_replace(['/', '-', '_'], ' ', $this->projectContext->projectName));
        $this->addText("# $title");

        $composerJson = json_decode($this->projectContext->composerJsonContent, true);
        if (isset($composerJson['description'])) {
            $this->addText('> '.$composerJson['description']);
        }

        $coverPath = 'cover.png';
        if ($this->projectContext->filesystem->exists($this->projectContext->fullPath($this->markdownSourceDir.'/'.$coverPath))) {
            $this->addText(sprintf('<img src="%s" alt="cover" />', $this->markdownSourceDir.'/'.$coverPath));
        } else {
            $this->addText('<!-- cover.png not found in markdown directory -->');
        }

        return $this;
    }

    /**
     * Adds a markdown file.
     *
     * @throws FileNotFoundException
     */
    public function addMarkdown(string $filepath): self
    {
        // retrieve markdown content from the specified file path
        $this->blocks[] = $this->projectContext->filesystem
            ->get(
                $this->projectContext->fullPath($this->markdownSourceDir.'/'.$filepath)
            );

        return $this;
    }

    /**
     * add a table of content for the full file
     */
    public function addTableOfContents(): self
    {
        // add a placeholder flag that will be replaced by the actual TOC later
        $this->blocks[] = self::TOC_FLAG;

        return $this;
    }

    /**
     * adds markdown text
     */
    public function addText(string $content): self
    {
        // add raw markdown text as a block
        $this->blocks[] = $content;

        return $this;
    }

    public function addContentProvider(MarkdownPieceInterface $provider): self
    {
        // add a provider object to the blocks
        $this->blocks[] = $provider;

        return $this;
    }

    public function badges(): Pieces\Badges
    {
        $piece = new Pieces\Badges;
        $this->addContentProvider($piece);

        return $piece;
    }

    public function classes(): Pieces\Classes
    {
        $piece = new Pieces\Classes;
        $this->addContentProvider($piece);

        return $piece;
    }

    public function tables(): Pieces\Tables
    {
        $piece = new Pieces\Tables;
        $this->addContentProvider($piece);

        return $piece;
    }

    public function toc(): Pieces\TOC
    {
        $piece = new Pieces\TOC;
        $this->addContentProvider($piece);

        return $piece;
    }

    public function image(string $text, string $path, string $url = ''): self
    {
        $this->blocks[] = sprintf('[![%s](%s)](%s)', $text, $path, $url);

        return $this;
    }

    /**
     * writes all added elements into one file
     */
    public function writeMarkdown(string $filepath): void
    {
        Config::output(sprintf(' INFO  Assembling Markdown to %s', $filepath));

        // resolve badges first to put them at the very top
        $badgeContent = '';
        $foundBadgeBlock = false;
        foreach ($this->blocks as $key => $block) {
            if ($block instanceof Pieces\Badges) {
                $badgeContent = $block->getContent($this->projectContext, $this->markdownSourceDir);
                $foundBadgeBlock = true;
                unset($this->blocks[$key]);
                break;
            }
        }
        if (! $foundBadgeBlock && ! $this->autoHeaderUsed) {
            $badgeContent = (new Pieces\Badges)->getContent($this->projectContext, $this->markdownSourceDir);
        }

        $content = $badgeContent ? trim($badgeContent)."\n\n" : '';

        // add warning text
        $content .= $this->sourceText;

        if (! $this->autoHeaderUsed) {
            // title
            $hasTitle = false;
            foreach ($this->blocks as $block) {
                if (is_string($block) && str_starts_with(trim($block), '# ')) {
                    $hasTitle = true;
                    break;
                }
            }
            if (! $hasTitle) {
                $composerJson = json_decode($this->projectContext->composerJsonContent, true);
                $title = $composerJson['name'] ?? $this->projectContext->repoName;
                $title = ucwords(str_replace(['/', '-', '_'], ' ', $title));
                $content .= "# $title\n\n";
                if (isset($composerJson['description'])) {
                    $content .= '> '.$composerJson['description']."\n\n";
                }
            }

            // cover image
            $coverPath = 'cover.png';
            if ($this->projectContext->filesystem->exists($this->projectContext->fullPath($this->markdownSourceDir.'/'.$coverPath))) {
                $content .= sprintf("![cover](%s)\n\n", $this->markdownSourceDir.'/'.$coverPath);
            }
        }

        // 1. Resolve all non-TOC blocks
        $resolvedBlocks = [];
        foreach ($this->blocks as $block) {
            if ($block instanceof MarkdownPieceInterface) {
                if ($block instanceof Pieces\TOC) {
                    $resolvedBlocks[] = $block; // keep the object for now
                } else {
                    $resolvedBlocks[] = $block->getContent($this->projectContext, $this->markdownSourceDir);
                }
            } else {
                $resolvedBlocks[] = $block;
            }
        }

        // 2. Identify TOC and provide it with other resolved blocks
        $onlyStrings = array_filter($resolvedBlocks, fn ($b) => is_string($b));

        foreach ($resolvedBlocks as &$block) {
            if ($block instanceof Pieces\TOC) {
                $block->setBlocks($onlyStrings);
                $block = $block->getContent($this->projectContext, $this->markdownSourceDir);
            }
            // check for legacy TOC flag
            if ($block === self::TOC_FLAG) {
                $toc = new Pieces\TOC;
                $toc->setBlocks($onlyStrings);
                $block = $toc->getContent($this->projectContext, $this->markdownSourceDir);
            }
        }
        unset($block);

        // 3. Assemble final content
        foreach ($resolvedBlocks as $block) {
            $text = is_string($block) ? trim($block) : '';
            if ($text) {
                $content .= $text."\n\n";
            }
        }

        // write the final content to the file
        $this->projectContext->filesystem->put($this->projectContext->fullPath($filepath), $content);
    }
}
